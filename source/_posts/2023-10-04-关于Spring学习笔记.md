---
title: 关于Spring学习笔记
date: 2023-10-04 20:07:18
tags: Spring
categories: [后端技术,Spring]
---

***
# 一、Spring
`spring`是一个轻量级的开发框架，为什么是轻量级，因为它所需jar包小，本身的大小也小，并且可以和其他任何框架集成。  

<br/>

***

<br/>


# 二、SpringBean的生命周期
**图解：**  
{% asset_img 1.jpg %}  
**1、实例化**  
在`AbstractAutowireCapableBeanFactory`类中的`createBeanInstance`方法中，根据反射的原理实例化bean对象。  
（1）`createBeanInstance`方法中第一行是获取`Class`对象；
（2）在`instantiateBean`方法中，有一行为`beanInstance=getInstantiationStrategy（）.instantiate(mbd,beanName,this)`；
（3）在`instantiate`方法中的`constructorToUse=clazz.getDeclaredConstructor()`，这个是使用`Class`对象获取这个对象的构造器；  
（4）在`instantiateClass`方法中的`ctor.newInstance(argsWithDefaultValues)`，根据构造器获取这个对象的实例。  


**2、初始化（自定义属性赋值）**  
在`AbstractAutowireCapableBeanFactory`类中的`populateBean`方法中，使用`set`方法完成赋值。（使用 PropertyValue 实体类的 set 方法完成赋值 setPropertyValue(pv.getName(), pv.getValue())；  


**3、检查`Aware`相关接口并设置依赖（容器对象属性赋值）**  
（1）`Aware`接口是用来干什么的？  
`Aware`接口相当于是一个标识作用，比如下面的例子：  
``` java
if(object instanceof Aware) {
    if(object instanceof BeanFactory) {
        do soming...
    }
    if(object instanceof ApplicationContext) {
        do soming...
    }
}
```
{% asset_img 2.jpg %}  
上图说明：  
相当于有多个接口去继承`Aware`接口，然后有多个类去实现那些接口，在`spring`容器启动的时候，会分别判断这些类的实例化对象`bean`属于哪个接口，然后按照那个接口的`set`方法去赋值。  
（下面4到7步，每个`bean`对象都会执行，意思就是：每个`bean`对象在初始化好之后，都会执行前置处理，然后执行`invokeInitMethods`方法去判断这个`bean`对象是否实现了`InitializingBean`接口，有没有扩展点，如果实现了，就执行`afterPropertiesSet`方法，这个方法相当于一个扩展点，相当于给这个`bean`对象增强，最后执行后置处理。）  

4、`BeanPostProcessor`前置处理  

5、检查`bean`对象实现了`InitializingBean`接口（执行初始化方法`invokeInitMethods`，默认没有）  

6、检查是否配置有自定义的`init-method`（执行初始化方法`invokeInitMethods`，默认没有）  

7、`BeanPostProcessor`后置处理

<br/>

***

<br/>


# 三、Spring三大核心
### 1、spring IOC（控制反转）和spring DI（依赖注入）
**1、什么是`IOC`控制反转和`DI`依赖注入？**  
之前我们创建对象，是使用`new`，`new`一个对象，但是在`spring`中，我们不用创建对象，由`spring`帮我们创建，`spring`相当于一个容器，我们把对象当成`bean`，将`bean`注入（依赖注入）到`spring`容器中，由`spring`容器自己帮我们创建和管理对象，在需要使用这个对象的地方使用反射（控制反转）来使用这个对象。  
例如：  
（1）以前传统方式创建一个对象：  
``` java
// 实体类对象
class Dog {
    private String name;
    private String color;

    public Dog() {
    }

    public Dog(String name, String color) {
        this.name = name;
        this.color = color;

    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String toString() {
        return "Dog{" +
                "name='" + name + '\'' +
                ", color='" + color + '\'' +
                '}';
    }
}

// 测试输出
public class Test {
    public static void main(String[] args) {
        Dog dog = new Dog("小黑狗", "黑色");
        System.out.println(dog.toString());
    }
}
```
（2）现在`spring`帮我们创建，去`xml`配置文件中配置`bean`对象：（也可以使用注解的方式，请查看`springboot`学习笔记）
``` xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
<!-- 配置属性id的值，相当于给这个实例一个变量名 -->
<!-- 配置属性class的值，就是Dog实体类的包路径 -->
    <bean id="dog" class="Dog">
	<!-- 配置property就相当于给对应的属性赋值 -->
        <property name="name" value="小黑狗"/>
        <property name="color" value="黑色"/>
    </bean>
</beans>
```
上述配置就相当于在java中的下述代码，差别就是这是写在配置文件中，不会造成程序的耦合：
``` java
Dog dog = new Dog();
apple.setName("小黑狗");
apple.setColor("黑色");
```
然后测试：
``` java
import Dog;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
    public static void main(String[] args) {
	// 通过ClassPathXmlApplicationContext加载dog.xml配置文件，路径是target目录下的相对路径
        ApplicationContext dogContext = new ClassPathXmlApplicationContext("classpath:dog.xml");
	// 通过反射获取dog实例对象
        Dog dog = dogContext.getBean("dog", Dog.class);
        System.out.println(dog.getName());
    }
}
```

**2、有参构造创建对象的例子（这里只列xml方式）**  
（1）有一个`student`类
``` java
package com.cn.zuo.pojo

Student{

    private String name;
    private int age;
    
    public StudentOne(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "StudentOne{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```
`student.xml`文件中：  
第一种：
``` xml
<bean id="student" class="com.cn.zuo.pojo.Student">
        <constructor-arg name="name" value="xiaoming" />
        <constructor-arg name="age" value="29" />
</bean>
```
第二种：
``` xml
<bean id="student" class="com.cn.zuo.pojo.Student">
        <constructor-arg index="0" value="xiaogang" />
        <constructor-arg index="1" value="27" />
    </bean>
```
第三种：
``` xml
<bean id="student" class="com.cn.zuo.pojo.Student">
        <constructor-arg type="java.lang.String" value="xiaohong" />
        <constructor-arg type="int" value="29" />
    </bean>
```

**3、bean的自动注入方法**
``` xml
//输入autowire="byName" 就实现自动装配了。
<bean id="people" calss="com.cn.zuo.pojo.People" autowire="byName">
    <property name="name" value="xiaoming" />
</bean>
说明：
    byname，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法一致。
    bytype，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致。
```

### 2、spring AOP（面向切面）

